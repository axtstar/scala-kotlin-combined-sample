/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package exposed.kotlin.sample

import org.jetbrains.exposed.dao.IntEntity
import org.jetbrains.exposed.dao.IntEntityClass
import org.jetbrains.exposed.dao.id.EntityID
import org.jetbrains.exposed.dao.id.IdTable
import org.jetbrains.exposed.sql.*
import org.jetbrains.exposed.sql.transactions.TransactionManager
import org.jetbrains.exposed.sql.transactions.transaction
import java.sql.ResultSet

fun main(args: Array<String>) {
    DBConnect.init()
    DynamicTables.getTest()
    DynamicTables.getRawSql()
}

object DBConnect{
    fun init(){
        Database.connect(
                "jdbc:postgresql://localhost:5432/dvdrental"
                , driver = "org.postgresql.Driver"
                , user = "postgres"
                , password = "postgres")
    }
}

/**
 * DAO object
 */
object DynamicTables : IdTable<Int>() {
    override val tableName: String
        get() = internalTableName

    val city_id = integer("city_id")
    val city = text("city")
    val country_id = integer("country_id")

    override val id: Column<EntityID<Int>> = city_id.entityId()

    var internalTableName = "city"

    fun <T:Any> String.execAndMap(transform : (ResultSet) -> T) : List<T> {
        val result = arrayListOf<T>()
        TransactionManager.current().exec(this) { rs ->
            while (rs.next()) {
                result += transform(rs)
            }
        }
        return result
    }

    fun getTest() {
        transaction {
            // print sql to std-out
            addLogger(StdOutSqlLogger)

            val result = DynamicTable.all()
            println("master: ${result.count()}")
            for ( x in result) {
                val xx = x.toModel()
                println("id: ${xx.city_id} city: ${xx.city} country_id: ${xx.country_id}")
            }
        }
    }

    fun getRawSql() {
        transaction {
            // print sql to std-out
            addLogger(StdOutSqlLogger)

            val result = "SELECT city.city, city.country_id, city.city_id FROM city".execAndMap<Dynamic> { rs ->
                val id = rs.getInt("city_id")
                Dynamic(
                        id,
                        rs.getString("city"),
                        rs.getInt("country_id"))
            }

            println("master: ${result.count()}")
            for ( x in result) {
                println("id: ${x.city_id} city: ${x.city} country_id: ${x.country_id}")
            }
        }

    }
}

/**
 * DTO object
 */
data class Dynamic(val city_id: Int, val city: String, val country_id: Int)

/**
 * DAO Entity class
 */
class DynamicTable(id: EntityID<Int>): IntEntity(id) {
    companion object : IntEntityClass<DynamicTable>(DynamicTables)

    var city_id by DynamicTables.id // DynamicTables.city_id is not working
    var city by DynamicTables.city
    var country_id by DynamicTables.country_id

    // DAO entity not serializable?
    // see https://github.com/JetBrains/Exposed/issues/497
    // solution
    // https://gist.github.com/felix19350/bcb39e50820dcc6872f624d2e925dd9a
    // Ktorm is another solution (because they are serializable)
    //https://github.com/vincentlauvlwj/Ktorm
    fun toModel(): Dynamic {
        val target = Dynamic(
                city_id = city_id.value,
                city = city,
                country_id = country_id
        )
        return target
    }
}
